# ============================================================
# Helper Functions
# ============================================================

# Check for internet connectivity
__has_internet() {
    ping -c 1 -W 1 1.1.1.1 >/dev/null 2>&1 || \
    ping -c 1 -W 1 8.8.8.8 >/dev/null 2>&1 || \
    ping -c 1 -W 1 cpan.org >/dev/null 2>&1
}

# Detect git project root (fallback: current dir)
__get_project_root() {
    if git rev-parse --show-toplevel >/dev/null 2>&1; then
        git rev-parse --show-toplevel
    else
        pwd
    fi
}

# Usage: encrypt <file_or_folder> [recipient_email]
#        echo "string" | encrypt [recipient_email]
#
# Encrypts a file, directory (auto-archives to .tar.gz), or stdin stream.
# If [recipient_email] is omitted, defaults to $IDENTITY, then $KEYID.
# Generates output in the format: <filename>.<timestamp>.enc
encrypt() {
    local recipient
    local output

    if [[ ! -t 0 ]]; then
        # If piping, the first argument (if present) is interpreted as the recipient
        recipient="${1:-${IDENTITY:-$KEYID}}"
        output="encrypted.$(date +%s).enc"

        if [[ -z "$recipient" ]]; then
            echo "Error: No recipient specified via argument or environment variables."
            return 1
        fi

        # GPG reads from stdin automatically when no input file is given
        gpg --encrypt --armor --output "$output" -r "$recipient" && \
        echo "Encrypted message from stdin -> $output"
        return 0
    fi

    local input="${1%/}" # Removes trailing slash
    # If file mode, 2nd arg is recipient. Fallback to env vars.
    recipient="${2:-${IDENTITY:-$KEYID}}"
    local file_to_encrypt="$input"
    local is_temp_file=false

    if [[ -z "$input" ]]; then
        echo "Usage: encrypt <filename/folder> [recipient]"
        echo "   or: echo 'message' | encrypt [recipient]"
        return 1
    fi

    if [[ -z "$recipient" ]]; then
        echo "Error: No recipient specified. Pass as 2nd arg or set \$IDENTITY."
        return 1
    fi

    # Handle Directory (Compress first)
    if [[ -d "$input" ]]; then
        echo "Directory detected. Archiving '$input'..."
        file_to_encrypt="${input}.tar.gz"
        tar -czf "$file_to_encrypt" "$input" || return 1
        is_temp_file=true
    elif [[ ! -f "$input" ]]; then
        echo "Error: File or Directory '$input' not found."
        return 1
    fi

    # Construct Output Name
    output="${file_to_encrypt}.$(date +%s).enc"

    # Encrypt
    gpg --encrypt --armor --output "$output" -r "$recipient" "$file_to_encrypt"
    local status=$?

    # Cleanup & Reporting
    if [[ $status -eq 0 ]]; then
        echo "Encrypted for $recipient: $output"
        if $is_temp_file; then
            rm "$file_to_encrypt"
        fi
    else
        echo "Encryption failed."
    fi
}

# Usage: decrypt <filename.enc>
#
# Decrypts the file and restores the original filename (removes .timestamp.enc).
# If the decrypted file is an archive (tar/tgz), it automatically extracts it
# and removes the intermediate archive file.
decrypt() {
    local input="$1"

    if [[ -z "$input" ]]; then
        echo "Usage: decrypt <filename.enc>"
        return 1
    fi

    # Strip the last two extensions (.timestamp.enc)
    local output="${input%.*.*}"

    # Safety check logic
    if [[ "$input" == "$output" ]]; then
         echo "Warning: Filename format unexpected. Removing only last extension."
         output="${input%.*}"
    fi

    # Decrypt
    gpg --decrypt --output "$output" "$input" || return 1
    echo "Decrypted: $output"

    # Handle Archives (Auto-extract)
    if [[ "$output" == *.tar.gz || "$output" == *.tgz || "$output" == *.tar ]]; then
        echo "Archive detected. Extracting..."
        tar -xf "$output" && rm "$output"
        echo "Extracted content from $output"
    fi
}

# Usage: sign <filename>
#
# Creates a detached, ASCII-armored signature file.
# The original file remains untouched.
# Generates output: <filename>.asc
sign() {
    local input="$1"
    local signer="${IDENTITY:-$KEYID}"

    if [[ -z "$input" ]]; then
        echo "Usage: sign <filename>"
        return 1
    fi

    if [[ ! -f "$input" ]]; then
        echo "Error: File '$input' not found."
        return 1
    fi

    if [[ -z "$signer" ]]; then
        echo "Error: \$IDENTITY or \$KEYID environment variables are not set."
        return 1
    fi

    local output="${input}.asc"

    # --detach-sign creates a separate file
    # --armor ensures it is ASCII text (not binary)
    gpg --detach-sign --armor --local-user "$signer" --output "$output" "$input" && \
    echo "Detached signature created: $output"
}

# Usage: verify <filename> <signature_file>
#
# Verifies the digital signature of a file using the provided signature file.
verify() {
    local input="$1"
    local sig_file="$2"

    if [[ -z "$input" ]] || [[ -z "$sig_file" ]]; then
        echo "Usage: verify <filename> <signature_file>"
        return 1
    fi

    if [[ ! -f "$input" ]]; then
        echo "Error: Data file '$input' not found."
        return 1
    fi

    if [[ ! -f "$sig_file" ]]; then
        echo "Error: Signature file '$sig_file' not found."
        return 1
    fi

    # GPG usage: verify <sig> <data>
    gpg --verify "$sig_file" "$input"
}

# Usage: add_secret API_KEY "super_secret_value"
# This runs the python tool, updates the file, AND exports to current shell
function add_secret() {
    if [ -z "$1" ] || [ -z "$2" ]; then
        echo "Usage: add_secret <KEY> <VALUE>"
        return 1
    fi

    # We eval the output of the python script to set the env var immediately
    eval "$(python3 ~/workspace/.dotfiles/bin/manage-secrets encrypt "$1" "$2")"
}

# Usage: load_secrets
# This prompts for YubiKey PIN (once per session/day) and exports all vars
function load_secrets() {
    echo "Loading secrets from YubiKey..."
    # Eval the output to export variables into current shell
    eval "$(python3 ~/workspace/.dotfiles/bin/manage-secrets decrypt)"
}
