#!/usr/bin/env python3
import os
import sys
import re
import subprocess
import base64
import argparse

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
SECRETS_FILE = os.path.join(
    os.path.dirname(os.path.dirname(os.path.realpath(__file__))), "dotfiles", ".secrets"
)
# Pattern: KEY=${enc:BASE64_BLOB}
REGEX_ENTRY = re.compile(r"^\s*([A-Z0-9_]+)=\$\{enc:(.+)\}\s*$")
# Pattern: KEY=VALUE (Unencrypted)
REGEX_UNENCRYPTED = re.compile(r"^\s*([A-Z0-9_]+)=(?!\$\{enc:)(.+)\s*$")


def get_gpg_recipient():
    """
    Tries to grab the git user.email to use as the GPG recipient.
    Fallback to user input if not found.
    """
    try:
        email = subprocess.check_output(
            ["git", "config", "user.email"], text=True
        ).strip()
        if email:
            return email
    except Exception:
        pass

    print(
        "Error: Could not detect GPG recipient (git user.email). Pass --recipient manually.",
        file=sys.stderr,
    )
    sys.exit(1)


def gpg_encrypt(cleartext, recipient):
    """
    Encrypts data using GPG (and YubiKey) -> returns Base64 string.
    """
    try:
        # We encrypt to binary, then base64 encode to keep it on one line in the file
        proc = subprocess.Popen(
            ["gpg", "--encrypt", "--recipient", recipient, "--trust-model", "always"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        encrypted_data, err = proc.communicate(input=cleartext.encode("utf-8"))

        if proc.returncode != 0:
            print(f"GPG Encryption failed: {err.decode()}", file=sys.stderr)
            sys.exit(1)

        return base64.b64encode(encrypted_data).decode("utf-8")
    except Exception as e:
        print(f"Error during encryption: {e}", file=sys.stderr)
        sys.exit(1)


def gpg_decrypt(b64_data):
    """
    Decrypts Base64 encoded GPG data -> returns cleartext string.
    """
    try:
        encrypted_bytes = base64.b64decode(b64_data)

        proc = subprocess.Popen(
            ["gpg", "--decrypt", "--quiet"],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        decrypted_data, err = proc.communicate(input=encrypted_bytes)

        if proc.returncode != 0:
            # Don't print stderr here to avoid spamming terminal if user cancels PIN
            raise Exception("GPG Decryption failed (Check PIN or YubiKey presence)")

        return decrypted_data.decode("utf-8").strip()
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


def load_secrets():
    """Reads the secrets file and returns lines."""
    if not os.path.exists(SECRETS_FILE):
        return []
    with open(SECRETS_FILE, "r") as f:
        return f.readlines()


def cmd_encrypt(args):
    """
    Flow 1: Encrypt KEY VALUE.
    Updates file and prints export command.
    """
    key = args.key.upper()
    value = args.value
    recipient = args.recipient or get_gpg_recipient()

    print(f"# Encrypting {key} for {recipient}...", file=sys.stderr)

    b64_encrypted = gpg_encrypt(value, recipient)
    new_line = f"{key}=${{enc:{b64_encrypted}}}\n"

    lines = load_secrets()
    updated_lines = []
    found = False

    for line in lines:
        # Update existing key if found
        if line.strip().startswith(f"{key}="):
            updated_lines.append(new_line)
            found = True
        else:
            updated_lines.append(line)

    if not found:
        if updated_lines and not updated_lines[-1].endswith("\n"):
            updated_lines[-1] += "\n"
        updated_lines.append(new_line)

    with open(SECRETS_FILE, "w") as f:
        f.writelines(updated_lines)

    print(f"export {key}='{value}'")
    print(f"# stored in {SECRETS_FILE}", file=sys.stderr)


def cmd_decrypt(args):
    """
    Flow 2: Decrypt all entries.
    Prints export commands for evaluation by shell.
    """
    lines = load_secrets()

    print("# Decrypting secrets...", file=sys.stderr)

    for line in lines:
        match = REGEX_ENTRY.match(line)
        if match:
            key = match.group(1)
            b64_blob = match.group(2)

            # Perform decryption (YubiKey will prompt for PIN if not cached)
            cleartext = gpg_decrypt(b64_blob)

            # Output for eval
            print(f"export {key}='{cleartext}'")


def cmd_verify(args):
    """
    Flow 3: Check for unencrypted values.
    Used for pre-commit hooks.
    """
    lines = load_secrets()
    has_error = False

    for i, line in enumerate(lines):
        line = line.strip()
        if not line or line.startswith("#"):
            continue

        # If it looks like a variable assignment but NOT an encrypted one
        if REGEX_UNENCRYPTED.match(line):
            print(
                f"[FAIL] Line {i+1}: Unencrypted secret found: {line.split('=')[0]}",
                file=sys.stderr,
            )
            has_error = True

        # If it is encrypted, verify base64 integrity (optional, but good practice)
        match = REGEX_ENTRY.match(line)
        if match:
            try:
                base64.b64decode(match.group(2), validate=True)
            except:
                print(
                    f"[FAIL] Line {i+1}: Malformed Base64 in secret: {match.group(1)}",
                    file=sys.stderr,
                )
                has_error = True
            continue
        has_error = True

    if has_error:
        print("Verification failed.", file=sys.stderr)
        sys.exit(1)
    else:
        print("Secrets verified encrypted.", file=sys.stderr)


def cmd_run(args):
    """
    Flow 4: Decrypt secrets into env and run a child process.
    """
    # 1. Load and Decrypt all secrets
    lines = load_secrets()
    env_updates = {}

    for line in lines:
        match = REGEX_ENTRY.match(line)
        if match:
            key = match.group(1)
            b64_blob = match.group(2)
            try:
                # Decrypt and store in a dict
                cleartext = gpg_decrypt(b64_blob)
                env_updates[key] = cleartext
            except Exception:
                print(f"Warning: Could not decrypt {key}, skipping.", file=sys.stderr)

    # 2. Merge with current environment
    # We copy the current environment so the child process has PATH, USER, etc.
    new_env = os.environ.copy()
    new_env.update(env_updates)

    # 3. Execute the command
    if not args.command_args:
        print("Error: No command provided to run.", file=sys.stderr)
        sys.exit(1)

    try:
        # Replace the current python process with the new command
        # This preserves PID and handles signals correctly
        os.execvpe(args.command_args[0], args.command_args, new_env)
    except FileNotFoundError:
        print(f"Error: Command not found: {args.command_args[0]}", file=sys.stderr)
        sys.exit(1)


def cmd_get(args):
    """
    Flow 5: Print a single decrypted secret raw (no export syntax).
    """
    target_key = args.key.upper()
    lines = load_secrets()

    for line in lines:
        match = REGEX_ENTRY.match(line)
        if match:
            key = match.group(1)
            if key == target_key:
                b64_blob = match.group(2)
                print(gpg_decrypt(b64_blob), end="")  # end='' prevents trailing newline
                return

    print(f"Error: Secret '{target_key}' not found.", file=sys.stderr)
    sys.exit(1)


def main():
    parser = argparse.ArgumentParser(description="Manage GPG-encrypted dotfile secrets")
    subparsers = parser.add_subparsers(dest="command", required=True)

    # Encrypt Command
    p_enc = subparsers.add_parser("encrypt", help="Encrypt a new secret")
    p_enc.add_argument("key", help="The environment variable name")
    p_enc.add_argument("value", help="The value to encrypt")
    p_enc.add_argument(
        "--recipient", help="GPG email recipient (defaults to git config)"
    )

    # Decrypt Command
    p_dec = subparsers.add_parser("decrypt", help="Decrypt secrets to stdout")

    # Verify Command
    p_ver = subparsers.add_parser("verify", help="Verify all secrets are encrypted")

    # Run Command
    p_run = subparsers.add_parser("run", help="Run a command with secrets loaded")
    p_run.add_argument(
        "command_args", nargs=argparse.REMAINDER, help="The command to run"
    )

    # Get Command
    p_get = subparsers.add_parser("get", help="Get a single secret value")
    p_get.add_argument("key", help="The variable name to retrieve")

    args = parser.parse_args()

    if args.command == "encrypt":
        cmd_encrypt(args)
    elif args.command == "decrypt":
        cmd_decrypt(args)
    elif args.command == "verify":
        cmd_verify(args)
    elif args.command == "run":
        cmd_run(args)
    elif args.command == "get":
        cmd_get(args)


if __name__ == "__main__":
    main()
