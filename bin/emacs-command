#!/usr/bin/env python3

"""
emacs-command - Emacs Client Wrapper

A smart Emacs client wrapper that starts the daemon if needed and
provides subcommands for common, globally-callable Emacs functions.
"""

import os
import sys
import time
import json
import subprocess

# --- Helper Functions ---

def run_emacs_command(lisp: str):
    """
    Executes a Lisp expression in Emacs, creating a new graphical frame.

    Args:
        lisp: The Lisp string to evaluate.
    """
    try:
        # -c = new graphical frame
        # -n = no-wait (return immediately)
        # -e = eval Lisp
        subprocess.run(
            ["emacsclient", "-c", "-n", "-e", lisp],
            check=True,
            capture_output=True,
            text=True,
            timeout=5
        )
    except subprocess.TimeoutExpired:
        print("Error: Emacs command timed out", file=sys.stderr)
    except subprocess.CalledProcessError as e:
        print(f"Error executing Emacs command: {e.stderr}", file=sys.stderr)
    except FileNotFoundError:
        print("Error: 'emacsclient' not found. Is Emacs installed?", file=sys.stderr)

def check_and_start_daemon():
    """
    Checks if the Emacs daemon is running. If not, starts it.
    """
    # 1. Ping the server
    try:
        subprocess.run(
            ["emacsclient", "-e", "1"],
            check=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            timeout=2
        )
        # Succeeded, daemon is running
        return
    except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
        # Fails if server isn't running or emacsclient isn't found
        pass

    # 2. Server not running, let's start it
    print("Emacs server not running. Starting new daemon...")
    workspace = os.environ.get("WORKSPACE", os.path.expanduser("~"))

    # Ensure workspace exists
    os.makedirs(workspace, exist_ok=True)

    try:
        # Start the daemon
        subprocess.Popen(
            ["emacs", "--daemon", f"--chdir={workspace}"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )

        # Wait with retries (poll for up to 3 seconds)
        print("Waiting for daemon to start...", end="", flush=True)
        for i in range(15):  # 15 * 0.2s = 3 seconds
            time.sleep(0.2)
            try:
                subprocess.run(
                    ["emacsclient", "-e", "1"],
                    check=True,
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL,
                    timeout=1
                )
                print(" done!")
                print("Emacs daemon started successfully.")
                return
            except:
                print(".", end="", flush=True)
                continue

        print()
        raise Exception("Daemon did not respond after 3 seconds")
    except Exception as e:
        print(f"Error: Failed to start Emacs daemon.", file=sys.stderr)
        print(f"Details: {e}", file=sys.stderr)
        sys.exit(1)

def get_clipboard_content() -> str:
    """Get clipboard content using available clipboard tools."""
    # Try multiple clipboard tools for better portability
    for cmd in [
        ["xclip", "-o", "-selection", "clipboard"],
        ["xsel", "--clipboard", "--output"],
        ["wl-paste"],  # Wayland support
    ]:
        try:
            return subprocess.check_output(
                cmd,
                text=True,
                stderr=subprocess.DEVNULL,
                timeout=2
            ).strip()
        except (FileNotFoundError, subprocess.CalledProcessError, subprocess.TimeoutExpired):
            continue

    print("Warning: No clipboard tool found (install xclip, xsel, or wl-paste)", file=sys.stderr)
    return ""

def show_help():
    """Display usage information."""
    print("""emacs-command - Emacs Client Wrapper

Usage: emacs-command [COMMAND] [ARGS...]

Commands:
  capture           Run org-capture
  bookmark          Jump to an Org bookmark
  agenda            Open org-agenda
  dired [PATH]      Open dired (prompts if no path given)
  browse [URL]      Browse URL in eww (uses clipboard if no URL)
  clip              Paste clipboard into new buffer
  find              Find file with completion
  search TEXT       Search for text in current directory
  M-x, mx           Run M-x (execute-extended-command)
  kill-daemon       Kill the Emacs daemon
  help, --help, -h  Show this help message

If no command is given, opens a new Emacs frame.
If given file path(s), opens them in Emacs.

Examples:
  emacs-command                    # Open new frame
  emacs-command capture            # Run org-capture
  emacs-command dired ~/Documents  # Open dired at ~/Documents
  emacs-command file.txt           # Open file.txt
  emacs-command *.py               # Open all Python files in splits
""")

# --- Command Handlers ---

def cmd_capture(args: list):
    """Run org-capture."""
    print("Running Org Capture...")
    run_emacs_command("(org-capture)")

def cmd_bookmark(args: list):
    """Jump to an Org bookmark."""
    print("Running Org Bookmark Jump...")
    run_emacs_command("(org-bookmark-jump)")

def cmd_agenda(args: list):
    """Open org-agenda."""
    print("Running Org Agenda...")
    # Use the 'd' custom command you have defined
    run_emacs_command('(org-agenda nil "d")')

def cmd_dired(args: list):
    """
    Open dired.
    - No args: Prompts for directory in Emacs.
    - 1 arg: Opens dired at that path.
    """
    if not args:
        print("Opening dired (prompting for directory)...")
        lisp = '(dired (read-directory-name "Dired (default ~): " "~/"))'
    else:
        path = os.path.abspath(os.path.expanduser(args[0]))
        lisp_path = json.dumps(path)
        print(f"Opening dired at: {path}")
        lisp = f'(dired {lisp_path})'

    run_emacs_command(lisp)

def cmd_browse(args: list):
    """
    Open a URL in Emacs's eww browser.
    - No args: Grabs URL from clipboard.
    - 1 arg: Opens that URL.
    """
    if not args:
        url = get_clipboard_content()
        if not url or not url.startswith(("http://", "https://", "www.")):
            print("No valid URL on clipboard.")
            return
        # Add https:// if it starts with www.
        if url.startswith("www."):
            url = "https://" + url
        print(f"Browsing clipboard URL: {url[:60]}...")
    else:
        url = args[0]
        # Add https:// if it starts with www.
        if url.startswith("www."):
            url = "https://" + url
        print(f"Browsing: {url}")

    lisp_url = json.dumps(url)
    run_emacs_command(f"(eww {lisp_url})")

def cmd_clip(args: list):
    """
    Take clipboard content and paste it into a new Emacs buffer.
    Extremely useful for saving snippets.
    """
    content = get_clipboard_content()
    if not content:
        print("Clipboard is empty.")
        return

    print("Pasting clipboard content into new buffer...")
    lisp_content = json.dumps(content)
    lisp = f"""
    (progn
      (switch-to-buffer-other-window (generate-new-buffer "*Clipboard*"))
      (insert {lisp_content})
      (goto-char (point-min)))
    """
    run_emacs_command(lisp)

def cmd_find(args: list):
    """Find files using Emacs's find-file with completion."""
    print("Running find-file...")
    run_emacs_command("(call-interactively 'find-file)")

def cmd_search(args: list):
    """
    Search for text in current directory using rgrep.
    """
    if not args:
        print("Running grep search (prompting for pattern)...")
        run_emacs_command("(call-interactively 'rgrep)")
    else:
        search_term = " ".join(args)
        print(f"Searching for: {search_term}")
        lisp_term = json.dumps(search_term)
        # Use rgrep with the search term
        run_emacs_command(f'(rgrep {lisp_term} "*" ".")')

def cmd_roam_find(args: list):
    """Open org-roam node finder."""
    print("Running Org Roam Find...")
    run_emacs_command("(org-roam-node-find)")

def cmd_roam_dailies(args: list):
    """Open org-roam dailies (requires org-roam-dailies extension)."""
    print("Opening Org Roam Daily...")
    # This will work if you add org-roam-dailies to your config
    run_emacs_command("(org-roam-dailies-capture-today)")

def cmd_magit(args: list):
    """Open Magit status."""
    print("Opening Magit...")
    run_emacs_command("(magit-status)")

def cmd_M_x(args: list):
    """
    Run M-x (execute-extended-command) in a new frame.
    This is a generic "run anything" command.
    """
    print("Running M-x...")
    run_emacs_command("(call-interactively 'execute-extended-command)")

def cmd_kill_daemon(args: list):
    """Kill the Emacs daemon gracefully."""
    print("Killing Emacs daemon...")
    try:
        subprocess.run(
            ["emacsclient", "-e", "(kill-emacs)"],
            check=True,
            timeout=5
        )
        print("Daemon stopped successfully.")
    except subprocess.CalledProcessError:
        print("Failed to stop daemon (it may not be running).", file=sys.stderr)
    except subprocess.TimeoutExpired:
        print("Warning: Daemon did not respond to kill command.", file=sys.stderr)

# --- Main Execution ---

# Map of command strings to handler functions
COMMANDS = {
    "capture": cmd_capture,
    "bookmark": cmd_bookmark,
    "agenda": cmd_agenda,
    "dired": cmd_dired,
    "browse": cmd_browse,
    "clip": cmd_clip,
    "find": cmd_find,
    "search": cmd_search,
    "M-x": cmd_M_x,
    "mx": cmd_M_x,  # Alias
    "kill-daemon": cmd_kill_daemon,
    "help": lambda args: show_help(),
    "--help": lambda args: show_help(),
    "-h": lambda args: show_help(),
}

def main():
    args = sys.argv[1:]

    # Handle help first (before starting daemon)
    if args and args[0] in ("--help", "-h", "help"):
        show_help()
        return

    # Check/start daemon for all other operations
    check_and_start_daemon()

    if not args:
        # No arguments given: default behavior
        # Open an empty frame
        print("Opening new Emacs frame...")
        subprocess.run(["emacsclient", "-c", "-n"])
        return

    command = args[0]
    command_args = args[1:]

    if command in COMMANDS:
        # First arg is a known command
        handler = COMMANDS[command]
        handler(command_args)
    else:
        # First arg is not a command, treat all args as files to open
        files = [os.path.abspath(os.path.expanduser(f)) for f in args]

        if len(files) == 1:
            print(f"Opening file: {files[0]}")
            subprocess.run(["emacsclient", "-c", "-n", files[0]])
        else:
            print(f"Opening {len(files)} files...")
            # Open first file, then open others in the same frame
            lisp = f"""(progn
              (find-file {json.dumps(files[0])})
              {' '.join(f'(find-file-other-window {json.dumps(f)})' for f in files[1:])})"""
            run_emacs_command(lisp)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nInterrupted.")
        sys.exit(130)
