#!/usr/bin/env bash
set -euo pipefail

# -----------------------------
# Default target directory
# -----------------------------
TARGET_DIR="${1:-$HOME}"

# -----------------------------
# Absolute path to this script
# -----------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SOURCE_BIN_DIR="$SCRIPT_DIR/bin"
DOTFILES_DIR="$SCRIPT_DIR/dotfiles"

# -----------------------------
# Sync dotfiles via Python
# -----------------------------
echo "Syncing dotfiles to $TARGET_DIR..."
if ! python3 "$SCRIPT_DIR/bin/sync-dotfiles" "$TARGET_DIR"; then
    echo "Error: sync-dotfiles failed. Aborting."
    exit 1
fi

# -----------------------------
# Create dotfiles alias
# -----------------------------

BASHRC_D_DIR="$HOME/.bashrc.d"
ALIAS_FILE="$BASHRC_D_DIR/dotfiles_alias"

mkdir -p "$BASHRC_D_DIR"

echo "Creating dotfiles alias at '$ALIAS_FILE'."
cat <<EOF > "$ALIAS_FILE"
# Alias to quickly jump to dotfiles directory
alias dotfiles='cd $SCRIPT_DIR'
EOF

echo "Done. '$ALIAS_FILE' created."

# -----------------------------
# Sync custom scripts
# -----------------------------
TARGET_BIN_DIR="$TARGET_DIR/bin"

echo "Syncing custom scripts to $TARGET_BIN_DIR..."

mkdir -p "$TARGET_BIN_DIR"
# Loop through all files in the source bin directory
for script_path in "$SOURCE_BIN_DIR"/*; do
    # Check if the glob found any files
    if [ -e "$script_path" ]; then
        script_name=$(basename "$script_path")
        target_path="$TARGET_BIN_DIR/$script_name"

        # Make the source script executable before linking
        chmod +x "$script_path"

        echo "  -> Linking $script_name"
        # Create or update the symlink, forcing overwrite
        ln -sf "$script_path" "$target_path"
    fi
done

# -----------------------------
# Git configuration
# -----------------------------
if command -v git &> /dev/null; then
    echo "Configuring global Git settings..."

    git config --global user.name "Ishmael Aqsar"
    git config --global user.email "ishmael-dev@aqsar.dev"
    git config --global core.excludesfile "$HOME/.gitignore_global"
    git config --global core.attributesfile "$HOME/.gitattributes"

    echo "Git configuration complete."
else
    echo "Git not found. Skipping git configuration."
fi

# -----------------------------
# GPG Agent Configuration
# -----------------------------
echo "Configuring GPG Agent..."

GNUPG_DIR="$HOME/.gnupg"
mkdir -p "$GNUPG_DIR"
chmod 700 "$GNUPG_DIR"

PINENTRY_PATH=""

if [[ "$OSTYPE" == "darwin"* ]]; then
    # macOS: Look for Homebrew pinentry-mac
    if command -v pinentry-mac >/dev/null; then
        PINENTRY_PATH=$(command -v pinentry-mac)
    elif [ -f "/opt/homebrew/bin/pinentry-mac" ]; then
        PINENTRY_PATH="/opt/homebrew/bin/pinentry-mac"
    elif [ -f "/usr/local/bin/pinentry-mac" ]; then
        PINENTRY_PATH="/usr/local/bin/pinentry-mac"
    else
        echo "Warning: pinentry-mac not found. Please run: brew install pinentry-mac"
    fi
else
    # Linux: Try standard pinentries in order of preference
    # We prefer GUI (gnome3/qt) if available, falling back to curses/tty
    if command -v pinentry-gnome3 >/dev/null; then
        PINENTRY_PATH=$(command -v pinentry-gnome3)
    elif command -v pinentry-qt >/dev/null; then
        PINENTRY_PATH=$(command -v pinentry-qt)
    elif command -v pinentry-curses >/dev/null; then
        PINENTRY_PATH=$(command -v pinentry-curses)
    else
        # Fallback to generic link
        PINENTRY_PATH="/usr/bin/pinentry"
    fi
fi

AGENT_CONF="$GNUPG_DIR/gpg-agent.conf"
echo "Writing gpg-agent.conf to $AGENT_CONF..."

cat <<EOF > "$AGENT_CONF"
# ---------------------------------------------------------
# GPG Agent Configuration (Generated by dotfiles/install)
# ---------------------------------------------------------

# Enable SSH support so YubiKey works for SSH auth
enable-ssh-support

# Cache PIN for 1 day (86400 seconds)
default-cache-ttl 86400
max-cache-ttl 86400

# Cache SSH keys for 1 day as well
default-cache-ttl-ssh 86400
max-cache-ttl-ssh 86400

# Pinentry Program detected by install script
EOF

if [ -n "$PINENTRY_PATH" ]; then
    echo "pinentry-program $PINENTRY_PATH" >> "$AGENT_CONF"
    echo "  -> Set pinentry to $PINENTRY_PATH"
else
    echo "# WARNING: No specific pinentry-program found during install" >> "$AGENT_CONF"
    echo "  -> Warning: Could not detect pinentry program."
fi

if command -v gpg-connect-agent >/dev/null; then
    echo "Reloading gpg-agent..."
    gpg-connect-agent reloadagent /bye
fi

# -----------------------------
# Import Public Key (Bootstrapping)
# -----------------------------
# If a public key is found in dotfiles/public.asc, this auto-imports it.
# Command to generate: gpg --armor --export [your-email] > dotfiles/public.asc

PUB_KEY="$DOTFILES_DIR/public.asc"
if [ -f "$PUB_KEY" ]; then
    echo "Importing public GPG key from $PUB_KEY..."
    gpg --import "$PUB_KEY"

    # This extracts the fingerprint and sets it to ultimate trust.
    FINGERPRINT=$(gpg --with-colons --import-options show-only --import "$PUB_KEY" \
        | grep -m 1 "^fpr" | awk -F: '{print $10}')

    if [ -n "$FINGERPRINT" ]; then
        echo "Setting ultimate trust for $FINGERPRINT..."
        echo -e "5\ny\n" | gpg --command-fd 0 --expert --edit-key "$FINGERPRINT" trust >/dev/null 2>&1
    fi
else
    echo "No public.asc found in dotfiles. Skipping GPG import."
fi

# -----------------------------
# Secrets Pre-commit Hook
# -----------------------------
# Installs the git hook to prevent committing unencrypted secrets
HOOK_PATH="$SCRIPT_DIR/.git/hooks/pre-commit"

if [ -d "$SCRIPT_DIR/.git" ]; then
    echo "Installing secrets pre-commit hook at $HOOK_PATH..."
    # Ensure hooks directory exists
    mkdir -p "$(dirname "$HOOK_PATH")"

    cat <<'EOF' > "$HOOK_PATH"
#!/usr/bin/env bash
# Pre-commit hook to ensure no unencrypted secrets are committed

REPO_ROOT="$(git rev-parse --show-toplevel)"
MANAGE_SECRETS="$REPO_ROOT/bin/manage-secrets"

if [ -x "$MANAGE_SECRETS" ]; then
    python3 "$MANAGE_SECRETS" verify
else
    echo "Warning: bin/manage-secrets not found or not executable. Skipping verification."
fi
EOF

    chmod +x "$HOOK_PATH"
    echo "Hook installed."
else
    echo "Skipping hook installation (.git directory not found)."
fi

echo "Dotfiles installation complete."
